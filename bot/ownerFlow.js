const Owner = require('../models/owner.model');
const ManagedChannel = require('../models/managedChannel.model');
const Withdrawal = require('../models/withdrawal.model');
const Transaction = require('../models/transaction.model');
const { nanoid } = require('nanoid');

const userStates = {};

const LANGUAGES = {
    en: {
        HELP_TEXTS: {
            main: "Welcome to the Help Center! Please choose a topic below.",
            gettingStarted: `*ЁЯЪА Getting Started: Adding Your Channel*\n\n1я╕ПтГг Use the \`/addchannel\` command.\n2я╕ПтГг Make the bot an **Admin** in your channel.\n3я╕ПтГг **Forward any message** from that channel to the bot.\n4я╕ПтГг Set your subscription prices (e.g., \`30 days 100 rs\`).\n\nThat's it! The bot will give you a unique link to share.`,
            dashboard: `*ЁЯУК Understanding Your Dashboard*\n\nЁЯУИ *Total Revenue:* Total sales generated.\nтЮЦ *Service Charge:* Our platform fee (${process.env.PLATFORM_COMMISSION_PERCENT}%).\nЁЯТ░ *Gross Earnings:* Your earning after the service charge.\nЁЯТ╕ *Total Paid Out:* Money you have successfully withdrawn.\nтЬЕ **Net Balance:** Money in your wallet, ready to be withdrawn.`,
            managingChannels: `*ЁЯУ║ Managing Your Channels*\n\nUse \`/mychannels\` to see your connected channels. The "тЪЩя╕П Manage" button gives you options to:\n\n- *Edit Plans:* Change prices.\n- *Get Link:* Get the subscriber link again.\n- *Remove Channel:* Delete the channel from the platform.`,
            withdrawals: `*ЁЯТ╕ The Withdrawal Process*\n\n1я╕ПтГг Use the \`/withdraw\` command when your balance is above тВ╣${process.env.MINIMUM_WITHDRAWAL_AMOUNT}.\n2я╕ПтГг Provide your UPI ID.\n3я╕ПтГг Confirm the request.\n4я╕ПтГг The admin will process the payment within 24 hours.`
        }
    },
    hi: {
        HELP_TEXTS: {
            main: "рд╕рд╣рд╛рдпрддрд╛ рдХреЗрдВрджреНрд░ рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ! рдХреГрдкрдпрд╛ рдиреАрдЪреЗ рдПрдХ рд╡рд┐рд╖рдп рдЪреБрдиреЗрдВред",
            gettingStarted: `*ЁЯЪА рд╢реБрд░реБрдЖрдд рдХрд░реЗрдВ: рдЕрдкрдирд╛ рдЪреИрдирд▓ рдЬреЛрдбрд╝реЗрдВ*\n\n1я╕ПтГг \`/addchannel\` рдХрдорд╛рдВрдб рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред\n2я╕ПтГг рдмреЙрдЯ рдХреЛ рдЕрдкрдиреЗ рдЪреИрдирд▓ рдореЗрдВ **рдПрдбрдорд┐рди** рдмрдирд╛рдПрдВред\n3я╕ПтГг рдЙрд╕ рдЪреИрдирд▓ рд╕реЗ рдХреЛрдИ рднреА рд╕рдВрджреЗрд╢ рдмреЙрдЯ рдХреЛ **рдлреЙрд░рд╡рд░реНрдб** рдХрд░реЗрдВред\n4я╕ПтГг рдЕрдкрдиреА рд╕рджрд╕реНрдпрддрд╛ рдХреА рдХреАрдорддреЗрдВ рд╕реЗрдЯ рдХрд░реЗрдВ (рдЬреИрд╕реЗ, \`30 рджрд┐рди 100 рд░реБрдкрдпреЗ\`)ред\n\nрдмрд╕! рдмреЙрдЯ рдЖрдкрдХреЛ рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдПрдХ рдпреВрдирд┐рдХ рд▓рд┐рдВрдХ рджреЗрдЧрд╛ред`,
            dashboard: `*ЁЯУК рдЕрдкрдиреЗ рдбреИрд╢рдмреЛрд░реНрдб рдХреЛ рд╕рдордЭреЗрдВ*\n\nЁЯУИ *рдХреБрд▓ рд░рд╛рдЬрд╕реНрд╡:* рд╕рднреА рдмрд┐рдХреНрд░реА рд╕реЗ рдЙрддреНрдкрдиреНрди рдХреБрд▓ рд░рд╛рд╢рд┐ред\nтЮЦ *рд╕реЗрд╡рд╛ рд╢реБрд▓реНрдХ:* рд╣рдорд╛рд░рд╛ рдкреНрд▓реЗрдЯрдлрд╝реЙрд░реНрдо рд╢реБрд▓реНрдХ (${process.env.PLATFORM_COMMISSION_PERCENT}%)ред\nЁЯТ░ *рд╕рдХрд▓ рдХрдорд╛рдИ:* рд╕реЗрд╡рд╛ рд╢реБрд▓реНрдХ рдХреЗ рдмрд╛рдж рдЖрдкрдХреА рдХрдорд╛рдИред\nЁЯТ╕ *рдХреБрд▓ рднреБрдЧрддрд╛рди:* рд╡рд╣ рдкреИрд╕рд╛ рдЬреЛ рдЖрдк рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдирд┐рдХрд╛рд▓ рдЪреБрдХреЗ рд╣реИрдВред\nтЬЕ **рдиреЗрдЯ рдмреИрд▓реЗрдВрд╕:** рдЖрдкрдХреЗ рд╡реЙрд▓реЗрдЯ рдореЗрдВ рд╡рд╣ рдкреИрд╕рд╛ рдЬреЛ рдирд┐рдХрд╛рд▓рдиреЗ рдХреЗ рд▓рд┐рдП рддреИрдпрд╛рд░ рд╣реИред`,
            managingChannels: `*ЁЯУ║ рдЕрдкрдиреЗ рдЪреИрдирд▓реЛрдВ рдХрд╛ рдкреНрд░рдмрдВрдзрди*\n\nрдЕрдкрдиреЗ рдЬреБрдбрд╝реЗ рд╣реБрдП рдЪреИрдирд▓реЛрдВ рдХреЛ рджреЗрдЦрдиреЗ рдХреЗ рд▓рд┐рдП \`/mychannels\` рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред "тЪЩя╕П рдкреНрд░рдмрдВрдзрд┐рдд рдХрд░реЗрдВ" рдмрдЯрди рдЖрдкрдХреЛ рдпреЗ рд╡рд┐рдХрд▓реНрдк рджреЗрддрд╛ рд╣реИ:\n\n- *рдкреНрд▓рд╛рди рд╕рдВрдкрд╛рджрд┐рдд рдХрд░реЗрдВ:* рдХреАрдорддреЗрдВ рдмрджрд▓реЗрдВред\n- *рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ:* рд╕рдмреНрд╕рдХреНрд░рд╛рдЗрдмрд░ рд▓рд┐рдВрдХ рдлрд┐рд░ рд╕реЗ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n- *рдЪреИрдирд▓ рд╣рдЯрд╛рдПрдВ:* рдкреНрд▓реЗрдЯрдлрд╝реЙрд░реНрдо рд╕реЗ рдЪреИрдирд▓ рд╣рдЯрд╛рдПрдВред`,
            withdrawals: `*ЁЯТ╕ рдирд┐рдХрд╛рд╕реА рдкреНрд░рдХреНрд░рд┐рдпрд╛*\n\n1я╕ПтГг рдЬрдм рдЖрдкрдХрд╛ рдмреИрд▓реЗрдВрд╕ тВ╣${process.env.MINIMUM_WITHDRAWAL_AMOUNT} рд╕реЗ рдКрдкрд░ рд╣реЛ рддреЛ \`/withdraw\` рдХрдорд╛рдВрдб рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдВред\n2я╕ПтГг рдЕрдкрдиреА UPI ID рдкреНрд░рджрд╛рди рдХрд░реЗрдВред\n3я╕ПтГг рдЕрдиреБрд░реЛрдз рдХреА рдкреБрд╖реНрдЯрд┐ рдХрд░реЗрдВред\n4я╕ПтГг рдПрдбрдорд┐рди 24 рдШрдВрдЯреЗ рдХреЗ рднреАрддрд░ рднреБрдЧрддрд╛рди рдХреА рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░реЗрдЧрд╛ред`
        }
    }
};

async function handleOwnerMessage(bot, msg) { /* ... (code from previous full answer) ... */ }
async function handleOwnerCallback(bot, cbq) { /* ... (code from previous full answer) ... */ }
// ... (all other functions)

module.exports = { handleOwnerMessage, handleOwnerCallback };

// For safety, providing the full, correct file content
async function handleOwnerMessage(bot, msg) {
    const fromId = msg.from.id.toString();
    const text = msg.text || "";

    let owner = await Owner.findOne({ telegram_id: fromId });
    if (!owner) {
        owner = await Owner.create({ telegram_id: fromId, first_name: msg.from.first_name, username: msg.from.username });
    }
    
    if (owner.is_banned) {
        return bot.sendMessage(fromId, `тЭМ Your account is currently banned. Please contact support: @${process.env.SUPER_ADMIN_USERNAME}`);
    }

    const state = userStates[fromId];
    if (state && state.awaiting) {
        if (state.awaiting === 'upi_id') await handleUpiInput(bot, msg, owner);
        else if (state.awaiting === 'plans') await handlePlansInput(bot, msg, owner);
        else if (state.awaiting === 'channel_forward') await handleChannelForward(bot, msg, owner);
        else if (state.awaiting === 'edit_plans') await handlePlansInput(bot, msg, owner, true);
        return;
    }

    switch (text) {
        case '/start': await showMainMenu(bot, msg.chat.id, owner); break;
        case '/addchannel': await startAddChannelFlow(bot, msg.chat.id, fromId); break;
        case '/dashboard': await showDashboard(bot, msg.chat.id, owner); break;
        case '/withdraw': await startWithdrawalFlow(bot, msg.chat.id, owner); break;
        case '/mychannels': await listMyChannels(bot, msg.chat.id, owner); break;
        case '/help': await showHelpMenu(bot, msg.chat.id, owner); break;
        default: await showMainMenu(bot, msg.chat.id, owner, `I didn't understand. Here are the options:`);
    }
}
async function handleOwnerCallback(bot, cbq) { const fromId = cbq.from.id.toString(); const chatId = cbq.message.chat.id; const messageId = cbq.message.message_id; const data = cbq.data; const owner = await Owner.findOne({ telegram_id: fromId }); await bot.answerCallbackQuery(cbq.id); const parts = data.split('_'); const command = parts[1]; const objectId = parts[2]; switch (command) { case 'mainmenu': await showMainMenu(bot, chatId, owner, "Welcome Back!", messageId); break; case 'add': await startAddChannelFlow(bot, chatId, fromId); break; case 'dashboard': await showDashboard(bot, chatId, owner, messageId); break; case 'withdraw': await startWithdrawalFlow(bot, chatId, owner); break; case 'mychannels': await listMyChannels(bot, chatId, owner, messageId); break; case 'help': await showHelpMenu(bot, chatId, owner, messageId); break; case 'setlang': owner.language = objectId; await owner.save(); await showMainMenu(bot, chatId, owner, "Language updated!", messageId); break; case 'helpsection': const lang = owner.language || 'en'; await bot.editMessageText(LANGUAGES[lang].HELP_TEXTS[objectId], { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: { inline_keyboard: [[{ text: "тмЕя╕П Back", callback_data: "owner_help" }]] } }); break; case 'transactions': await showTransactionHistory(bot, chatId, owner, messageId); break; case 'withdrawalhistory': await showWithdrawalHistory(bot, chatId, owner, messageId); break; case 'channelstats': await showChannelStats(bot, chatId, owner, messageId); break; case 'managechannel': await showChannelManagementMenu(bot, chatId, objectId, messageId); break; case 'getlink': await sendChannelLink(bot, chatId, objectId); break; case 'editplans': userStates[fromId] = { awaiting: 'edit_plans', channel_db_id: objectId }; await bot.sendMessage(chatId, `Send the new plans in the format:\n\n\`30 days 100 rs\``, { parse_mode: 'Markdown' }); break; case 'removechannel': await confirmRemoveChannel(bot, chatId, objectId, messageId); break; case 'confirmremove': await removeChannel(bot, chatId, objectId, messageId); break; case 'withdrawconfirm': await handleWithdrawConfirm(bot, cbq, owner); break; case 'withdrawcancel': delete userStates[fromId]; await bot.editMessageText("Withdrawal request cancelled.", { chat_id: chatId, message_id: messageId }); break; } }
async function showMainMenu(bot, chatId, owner, text = "Welcome, Channel Owner!", messageId = null) { const lang = owner.language || 'en'; const otherLang = lang === 'en' ? 'hi' : 'en'; const langText = lang === 'en' ? 'ЁЯЗоЁЯЗ│ Switch to Hindi' : 'ЁЯЗмЁЯЗз Switch to English'; const keyboard = { inline_keyboard: [ [{ text: "ЁЯУК My Dashboard", callback_data: "owner_dashboard" }, { text: "тЮХ Add a New Channel", callback_data: "owner_add" }], [{ text: "ЁЯУ║ My Channels", callback_data: "owner_mychannels" }, { text: "тЭУ Help & Support", callback_data: "owner_help" }], [{ text: langText, callback_data: `owner_setlang_${otherLang}`}] ]}; if (messageId) await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, reply_markup: keyboard }); else await bot.sendMessage(chatId, text, { reply_markup: keyboard }); }
async function showHelpMenu(bot, chatId, owner, messageId = null) { const lang = owner.language || 'en'; const help = LANGUAGES[lang].HELP_TEXTS; const keyboard = { inline_keyboard: [ [{ text: "ЁЯЪА Getting Started", callback_data: "owner_helpsection_gettingStarted" }], [{ text: "ЁЯУК Understanding Dashboard", callback_data: "owner_helpsection_dashboard" }], [{ text: "ЁЯУ║ Managing Channels", callback_data: "owner_helpsection_managingChannels" }], [{ text: "ЁЯТ╕ Withdrawal Process", callback_data: "owner_helpsection_withdrawals" }], [{ text: "тмЕя╕П Back to Main Menu", callback_data: "owner_mainmenu" }] ]}; if(messageId) await bot.editMessageText(help.main, { chat_id: chatId, message_id: messageId, reply_markup: keyboard }); else await bot.sendMessage(chatId, help.main, { reply_markup: keyboard }); }
async function handleChannelForward(bot, msg, owner) { const fromId = owner.telegram_id; if (msg.forward_from_chat) { const channelId = msg.forward_from_chat.id.toString(); const channelName = msg.forward_from_chat.title; try { const botMember = await bot.getChatMember(channelId, (await bot.getMe()).id); if (botMember.status !== 'administrator') { await bot.sendMessage(fromId, `тЭМ Bot is not an admin in "${channelName}". Please make the bot an admin and try again.`); delete userStates[fromId]; return; } userStates[fromId] = { awaiting: 'plans', channel_id: channelId, channel_name: channelName }; await bot.sendMessage(fromId, `тЬЕ Great! Bot is an admin in "${channelName}".\n\nNow, send subscription plans in this format:\n\n\`30 days 100 rs\`\n\`90 days 250 rs\``, { parse_mode: 'Markdown' }); } catch (error) { await bot.sendMessage(fromId, `тЭМ An error occurred. Please make sure the bot is an admin in your channel and try again.`); delete userStates[fromId]; } } else { await bot.sendMessage(fromId, `That was not a forwarded message. Please forward a message from your channel.`); }};
async function handlePlansInput(bot, msg, owner, isEdit = false) { const fromId = owner.telegram_id; const state = userStates[fromId]; const lines = msg.text.split('\n'); const plans = []; let parseError = false; for (const line of lines) { const parts = line.match(/(\d+)\s+days?\s+(\d+)\s+rs?/i); if (parts) { plans.push({ days: parseInt(parts[1]), price: parseInt(parts[2]) }); } else if (line.trim() !== '') { parseError = true; break; } } if (parseError || plans.length === 0) { await bot.sendMessage(fromId, `тЭМ Invalid format. Please use the format like: \`30 days 100 rs\`. Try again.`); } else { if (isEdit) { await ManagedChannel.findByIdAndUpdate(state.channel_db_id, { plans: plans }); await bot.sendMessage(fromId, `тЬЕ Plans updated successfully!`); } else { const uniqueKey = nanoid(8); await ManagedChannel.create({ owner_id: owner._id, channel_id: state.channel_id, channel_name: state.channel_name, unique_start_key: uniqueKey, plans: plans }); const link = `https://t.me/${(await bot.getMe()).username}?start=${uniqueKey}`; await bot.sendMessage(fromId, `тЬЕ Channel Added Successfully!\n\nShare this link with your users:\n\n\`${link}\``, { parse_mode: 'Markdown' }); } delete userStates[fromId]; }};
async function handleUpiInput(bot, msg, owner) { const fromId = owner.telegram_id; const upiId = msg.text.trim(); const amountToWithdraw = owner.wallet_balance; userStates[fromId] = { awaiting: 'withdraw_confirm', upi_id: upiId, amount: amountToWithdraw }; const confirmationKeyboard = { inline_keyboard: [[{ text: "тЬЕ Yes, Confirm", callback_data: "owner_withdrawconfirm" }, { text: "тЭМ No, Cancel", callback_data: "owner_withdrawcancel" }]] }; await bot.sendMessage(fromId, `Please confirm:\n\nYou want to withdraw **тВ╣${amountToWithdraw.toFixed(2)}** to **${upiId}**?`, { parse_mode: 'Markdown', reply_markup: confirmationKeyboard }); };
async function handleWithdrawConfirm(bot, cbq, owner) { const state = userStates[owner.telegram_id]; if (state && state.awaiting === 'withdraw_confirm') { await Withdrawal.create({ owner_id: owner._id, amount: state.amount, upi_id: state.upi_id }); await Owner.findByIdAndUpdate(owner._id, { $inc: { wallet_balance: -state.amount } }); await bot.editMessageText(`тЬЕ Your withdrawal request for **тВ╣${state.amount.toFixed(2)}** has been submitted. It will be processed within 24 hours.`, { chat_id: cbq.message.chat.id, message_id: cbq.message.message_id, parse_mode: 'Markdown' }); await bot.sendMessage(process.env.SUPER_ADMIN_ID, `ЁЯФФ **New Withdrawal Request!**\n\nOwner: ${owner.first_name} (\`${owner.telegram_id}\`)\nAmount: \`тВ╣${state.amount.toFixed(2)}\`\nUPI ID: \`${state.upi_id}\``, { parse_mode: 'Markdown' }); delete userStates[owner.telegram_id]; }};
async function showDashboard(bot, chatId, owner, messageId = null) { const commission_percent = parseFloat(process.env.PLATFORM_COMMISSION_PERCENT); const totalEarnings = owner.total_earnings || 0; const service_charge_amount = (totalEarnings * commission_percent) / 100; const walletBalance = owner.wallet_balance || 0; const paidOutAggregation = await Withdrawal.aggregate([ { $match: { owner_id: owner._id, status: 'approved' } }, { $group: { _id: null, total: { $sum: '$amount' } } } ]); const totalPaidOut = paidOutAggregation.length > 0 ? paidOutAggregation[0].total : 0; const grossEarnings = totalEarnings - service_charge_amount; const text = `*ЁЯУК Your Financial Dashboard*\n\n*Summary:*\nЁЯУИ Total Revenue: *тВ╣${totalEarnings.toFixed(2)}*\nтЮЦ Service Charge (${commission_percent}%): *- тВ╣${service_charge_amount.toFixed(2)}*\n------------------------------------\nЁЯТ░ Gross Earnings: *тВ╣${grossEarnings.toFixed(2)}*\n   _(${totalEarnings.toFixed(2)} - ${service_charge_amount.toFixed(2)})_\n\n*Payouts:*\nЁЯТ╕ Total Paid Out: *- тВ╣${totalPaidOut.toFixed(2)}*\n------------------------------------\nтЬЕ **Net Balance (Withdrawable):** **тВ╣${walletBalance.toFixed(2)}**`; const keyboard = { inline_keyboard: [ [{ text: "ЁЯТ╕ Request Withdrawal", callback_data: "owner_withdraw" }], [{ text: "ЁЯУЬ Transaction History", callback_data: "owner_transactions" }, { text: "ЁЯТ╕ Withdrawal History", callback_data: "owner_withdrawalhistory" }], [{ text: "ЁЯУ║ Channel Stats", callback_data: "owner_channelstats" }], [{ text: "тмЕя╕П Back to Main Menu", callback_data: "owner_mainmenu" }] ]}; if (messageId) await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); else await bot.sendMessage(chatId, text, { parse_mode: 'Markdown', reply_markup: keyboard }); }
async function showTransactionHistory(bot, chatId, owner, messageId) { const transactions = await Transaction.find({ owner_id: owner._id }).sort({ timestamp: -1 }).limit(10); let text = "*ЁЯУЬ Last 10 Transactions:*\n\n"; if (transactions.length === 0) { text = "You have no transactions yet."; } else { transactions.forEach(t => { const date = new Date(t.timestamp).toLocaleDateString('en-IN'); text += `*Sale:* +тВ╣${t.amount_paid.toFixed(2)} | *Fee:* -тВ╣${t.commission_charged.toFixed(2)} | *Net:* +тВ╣${t.amount_credited_to_owner.toFixed(2)} _(${date})_\n`; }); } const keyboard = { inline_keyboard: [[{ text: "тмЕя╕П Back to Dashboard", callback_data: "owner_dashboard" }]] }; await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); }
async function showWithdrawalHistory(bot, chatId, owner, messageId) { const withdrawals = await Withdrawal.find({ owner_id: owner._id }).sort({ requested_at: -1 }).limit(10); let text = "*ЁЯТ╕ Last 10 Withdrawals:*\n\n"; if (withdrawals.length === 0) { text = "You have no withdrawal history."; } else { const status_emoji = { pending: 'тМЫя╕П', approved: 'тЬЕ', rejected: 'тЭМ' }; withdrawals.forEach(w => { const date = new Date(w.requested_at).toLocaleDateString('en-IN'); text += `${status_emoji[w.status]} *тВ╣${w.amount.toFixed(2)}* to ${w.upi_id} _(${date})_ - *${w.status}*\n`; }); } const keyboard = { inline_keyboard: [[{ text: "тмЕя╕П Back to Dashboard", callback_data: "owner_dashboard" }]] }; await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); }
async function showChannelStats(bot, chatId, owner, messageId) { const stats = await Transaction.aggregate([ { $match: { owner_id: owner._id } }, { $group: { _id: '$channel_id', totalRevenue: { $sum: '$amount_paid' }, count: { $sum: 1 } } } ]); let text = "*ЁЯУ║ Channel-wise Earnings:*\n\n"; if (stats.length === 0) { text = "No sales data available for any channel yet."; } else { for (const stat of stats) { const channel = await ManagedChannel.findOne({ channel_id: stat._id }); const channelName = channel ? channel.channel_name : `Deleted Channel (${stat._id})`; text += `*${channelName}:*\n- Total Revenue: *тВ╣${stat.totalRevenue.toFixed(2)}*\n- Total Sales: *${stat.count}*\n\n`; } } const keyboard = { inline_keyboard: [[{ text: "тмЕя╕П Back to Dashboard", callback_data: "owner_dashboard" }]] }; await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); }
async function startAddChannelFlow(bot, chatId, fromId) { userStates[fromId] = { awaiting: 'channel_forward' }; await bot.sendMessage(chatId, `Okay, let's add a new channel.\n\n*Step 1:* Make this bot an Admin in your channel.\n\n*Step 2:* Now, **forward any message** from that channel here.`, { parse_mode: "Markdown" }); }
async function startWithdrawalFlow(bot, chatId, owner) { const minWithdrawal = parseFloat(process.env.MINIMUM_WITHDRAWAL_AMOUNT); if (owner.wallet_balance < minWithdrawal) { await bot.sendMessage(chatId, `тЭМ Sorry, you need at least тВ╣${minWithdrawal.toFixed(2)} to request a withdrawal. Your current balance is тВ╣${owner.wallet_balance.toFixed(2)}.`); return; } userStates[owner.telegram_id] = { awaiting: 'upi_id' }; await bot.sendMessage(chatId, `Your current withdrawable balance is тВ╣${owner.wallet_balance.toFixed(2)}.\n\nPlease enter your UPI ID:`); }
async function listMyChannels(bot, chatId, owner, messageId = null) { const channels = await ManagedChannel.find({ owner_id: owner._id }); let text = "*Your Connected Channels:*\n\n"; const keyboardRows = []; if (channels.length === 0) { text = "You haven't connected any channels yet."; } else { channels.forEach(ch => { keyboardRows.push([{ text: ch.channel_name, callback_data: `none` }, { text: "тЪЩя╕П Manage", callback_data: `owner_managechannel_${ch._id}` }]); }); } keyboardRows.push([{ text: "тмЕя╕П Back to Main Menu", callback_data: "owner_mainmenu" }]); const opts = { chat_id: chatId, parse_mode: 'Markdown', reply_markup: { inline_keyboard: keyboardRows } }; if(messageId) { opts.message_id = messageId; await bot.editMessageText(text, opts); } else { await bot.sendMessage(chatId, text, opts); } }
async function showChannelManagementMenu(bot, chatId, channelDbId, messageId) { const channel = await ManagedChannel.findById(channelDbId); if (!channel) { await bot.editMessageText("Sorry, this channel was not found.", { chat_id: chatId, message_id: messageId }); return; } const text = `Managing channel: *${channel.channel_name}*`; const keyboard = { inline_keyboard: [ [{ text: "тЬПя╕П Edit Plans", callback_data: `owner_editplans_${channelDbId}` }, { text: "ЁЯФЧ Get Link", callback_data: `owner_getlink_${channelDbId}` }], [{ text: "ЁЯЧСя╕П Remove Channel", callback_data: `owner_removechannel_${channelDbId}` }], [{ text: "тмЕя╕П Back to My Channels", callback_data: "owner_mychannels" }] ]}; await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); }
async function sendChannelLink(bot, chatId, channelDbId) { const channel = await ManagedChannel.findById(channelDbId); const link = `https://t.me/${(await bot.getMe()).username}?start=${channel.unique_start_key}`; await bot.sendMessage(chatId, `Here is the subscriber link for *${channel.channel_name}*:\n\n\`${link}\``, { parse_mode: 'Markdown' }); }
async function confirmRemoveChannel(bot, chatId, channelDbId, messageId) { const text = "тЪая╕П **Are you sure?**\n\nRemoving this channel will stop new subscriptions, but existing subscribers will remain active until their plan expires. This action cannot be undone."; const keyboard = { inline_keyboard: [ [{ text: "ЁЯЧСя╕П Yes, Remove It", callback_data: `owner_confirmremove_${channelDbId}` }], [{ text: "тмЕя╕П No, Go Back", callback_data: `owner_managechannel_${channelDbId}` }] ]}; await bot.editMessageText(text, { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown', reply_markup: keyboard }); }
async function removeChannel(bot, chatId, channelDbId, messageId) { await ManagedChannel.findByIdAndDelete(channelDbId); await bot.editMessageText("тЬЕ Channel has been successfully removed from the platform.", { chat_id: chatId, message_id: messageId }); }

module.exports = { handleOwnerMessage, handleOwnerCallback };
